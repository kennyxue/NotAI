# 问题追踪日志

本文档记录项目开发过程中遇到的问题及其解决方案。

## 问题分类

### 1. 环境配置问题

### 2. 构建问题

#### 2.1 FileManager 命名冲突
- 日期：2025/2/6
- 类型：构建错误
- 描述：Constants.swift 文件中的 FileManager 枚举与 Foundation.FileManager 产生命名冲突
- 影响：项目无法编译，出现 "Type 'Constants.FileManager' has no member 'default'" 等错误
- 解决方案：将 Constants.FileManager 重命名为 Constants.FileManagerConstants，并明确指定 Foundation.FileManager
- 预防措施：
  1. 避免使用与系统框架相同的命名
  2. 使用更具描述性的命名来避免冲突
  3. 在使用系统类型时，明确指定命名空间

#### 2.2 SwiftUI API 废弃警告
- 日期：2025/2/6
- 类型：编译警告
- 描述：onChange(of:perform:) 在 macOS 14.0 中已废弃
- 影响：产生编译警告，未来可能不受支持
- 解决方案：使用新的 onChange 方法，包含两个或零个参数的闭包
- 预防措施：
  1. 及时关注 API 更新和废弃通知
  2. 定期更新代码以使用最新的 API
  3. 在开发时优先使用最新推荐的 API

#### 2.3 未使用变量警告
- 日期：2025/2/6
- 类型：编译警告
- 描述：变量定义后未使用
- 影响：代码冗余，可能影响可维护性
- 解决方案：移除未使用的变量绑定，直接使用条件判断
- 预防措施：
  1. 代码审查时注意检查未使用的变量
  2. 使用编译器警告来帮助发现未使用的变量
  3. 保持代码简洁，避免不必要的变量声明

#### 2.4 类型不符合 Hashable 协议错误
- 日期：2025/2/6
- 类型：构建错误
- 描述：Directory 类型在用于 List selection 时需要遵循 Hashable 协议
- 影响：项目无法编译，出现 "requires that 'Directory' conform to 'Hashable'" 错误
- 解决方案：
  1. 让 Directory 结构体遵循 Hashable 协议
  2. 实现 hash(into:) 方法
  3. 实现 == 操作符
- 预防措施：
  1. 在使用 SwiftUI 的选择功能时，确保相关类型遵循必要的协议
  2. 使用 Xcode 的协议一致性检查
  3. 查看 API 文档中的类型要求

#### 2.5 类型不符合 Equatable 协议错误
- 日期：2025/2/6
- 类型：构建错误
- 描述：Document 类型在用于 onChange 监听时需要遵循 Equatable 协议
- 影响：项目无法编译，出现 "requires that 'Document' conform to 'Equatable'" 错误
- 解决方案：
  1. 让 Document 结构体遵循 Equatable 协议
  2. 实现 == 操作符，基于 id 进行比较
- 预防措施：
  1. 在使用 SwiftUI 的 onChange 修饰符时，确保相关类型遵循必要的协议
  2. 使用 Xcode 的协议一致性检查
  3. 查看 API 文档中的类型要求
  4. 注意 Optional 类型的协议要求

### 3. 运行时问题

### 4. 性能问题

### 5. UI/UX问题

#### 5.1 界面布局优化
- 日期：2025/2/6
- 类型：UI改进
- 描述：需要优化界面布局，添加侧边栏显示控制
- 影响：用户体验和界面灵活性
- 解决方案：
  1. 添加侧边栏显示控制按钮
  2. 实现侧边栏的动画显示/隐藏
  3. 使用常量管理UI尺寸和样式
  4. 优化工具栏布局
- 预防措施：
  1. 使用统一的UI常量管理系统
  2. 实现响应式布局
  3. 保持界面设计的一致性

#### 5.2 侧边栏功能增强
- 日期：2025/2/6
- 类型：功能增强
- 描述：侧边栏需要支持目录和搜索功能
- 影响：用户体验和功能完整性
- 解决方案：
  1. 添加目录/搜索切换标签
  2. 实现目录的层级显示
  3. 添加搜索功能
  4. 优化目录树的展开/折叠
- 预防措施：
  1. 使用合适的数据结构管理目录层级
  2. 实现高效的搜索算法
  3. 注意大量数据时的性能优化

#### 5.3 目录布局调整
- 日期：2025/2/6
- 类型：UI改进
- 描述：需要将父子目录改为左右并列显示，并实现目录选择联动
- 影响：用户交互体验
- 解决方案：
  1. 修改VSplitView为HStack实现左右布局
  2. 使用List的selection属性实现目录选择
  3. 添加目录选择的状态监听
  4. 优化目录项的视觉样式
- 预防措施：
  1. 使用SwiftUI的声明式布局
  2. 实现适当的状态管理
  3. 注意布局的响应式调整

#### 5.4 侧边栏宽度调整
- 日期：2025/2/6
- 类型：UI改进
- 描述：右侧边栏隐藏时左侧边栏宽度不正确
- 影响：界面布局不合理
- 解决方案：
  1. 使用固定宽度替代最小/最大宽度
  2. 调整布局约束
  3. 优化窗口尺寸设置
- 预防措施：
  1. 使用常量管理尺寸
  2. 测试不同窗口状态
  3. 注意布局约束的影响

#### 5.5 文档编辑功能增强
- 日期：2025/2/6
- 类型：功能增强
- 描述：需要实现文档编辑和状态管理
- 影响：用户编辑体验
- 解决方案：
  1. 添加文档标题显示
  2. 实现文档内容编辑
  3. 优化状态管理
  4. 添加更多测试数据
- 预防措施：
  1. 使用适当的状态管理模式
  2. 实现数据的双向绑定
  3. 注意性能优化

#### 5.6 目录选择功能问题
- 日期：2025/2/6
- 类型：功能缺陷
- 描述：点击父级目录时没有显示对应的子级目录
- 影响：用户无法正常浏览和选择文档
- 解决方案：
  1. 修改目录列表实现方式，从 List 改为 ScrollView + LazyVStack
  2. 使用 onTapGesture 替代 selection 绑定
  3. 添加选中状态的视觉反馈
  4. 优化目录项的布局和样式
- 预防措施：
  1. 在实现状态管理时进行充分测试
  2. 确保状态更新能触发视图刷新
  3. 添加适当的视觉反馈
  4. 注意用户交互的连贯性

#### 5.7 文档切换功能问题
- 日期：2025/2/6
- 类型：功能缺陷
- 描述：切换子级目录时主编辑区域内容未更新
- 影响：用户无法正确查看不同文档的内容
- 解决方案：
  1. 添加文档切换的状态监听
  2. 实现文档内容的双向绑定
  3. 优化文档状态管理
  4. 完善文档更新逻辑
- 预防措施：
  1. 确保状态变化能正确触发视图更新
  2. 实现完整的状态管理生命周期
  3. 添加必要的状态监听
  4. 测试各种状态切换场景

#### 5.8 响应式布局问题
- 日期：2025/2/6
- 类型：UI缺陷
- 描述：窗口宽度调整时出现显示问题，部分侧边栏内容无法显示，且窗口最小宽度限制不合理
- 影响：用户界面在不同窗口尺寸下的可用性
- 解决方案：
  1. 重新计算并设置合理的窗口最小宽度（1000）
  2. 为分隔线和边距添加专门的常量
  3. 给予编辑区域更高的布局优先级
  4. 在计算侧边栏宽度时考虑分隔线宽度
  5. 确保所有区域都有合理的最小宽度限制
- 预防措施：
  1. 在开发时就考虑不同屏幕尺寸的适配
  2. 使用合理的布局约束和尺寸限制
  3. 测试不同窗口尺寸下的显示效果
  4. 建立清晰的响应式设计规范
  5. 仔细计算所有UI元素所需的最小空间

#### 5.9 动画性能优化
- 日期：2025/2/6
- 类型：性能优化
- 描述：侧边栏切换和内容更新时的动画性能需要优化
- 影响：用户体验和界面流畅度
- 解决方案：
  1. 使用合适的动画持续时间
  2. 优化动画触发时机
  3. 减少不必要的动画
  4. 使用合适的动画曲线
  5. 避免动画叠加
- 预防措施：
  1. 在开发时就注意动画性能
  2. 使用性能分析工具监控
  3. 设置合理的动画参数
  4. 避免过度使用动画

#### 5.10 滚动性能优化
- 日期：2025/2/6
- 类型：性能优化
- 描述：长列表滚动时出现卡顿现象
- 影响：用户体验和界面响应性
- 解决方案：
  1. 使用LazyVStack替代普通VStack
  2. 实现视图的延迟加载
  3. 优化列表项的渲染
  4. 减少不必要的视图更新
  5. 使用ScrollViewReader优化滚动
- 预防措施：
  1. 合理使用延迟加载
  2. 监控内存使用情况
  3. 优化数据结构
  4. 实现分页加载

#### 5.11 主题切换优化
- 日期：2025/2/6
- 类型：UI改进
- 描述：深色模式切换时出现闪烁现象
- 影响：用户体验和视觉连续性
- 解决方案：
  1. 使用系统颜色实现自动适配
  2. 优化颜色切换动画
  3. 统一使用颜色常量
  4. 处理自定义颜色的适配
  5. 优化图标和图片的切换
- 预防措施：
  1. 使用系统提供的颜色
  2. 测试不同主题下的显示效果
  3. 避免硬编码颜色值
  4. 注意对比度和可读性

#### 5.12 SwiftUI frame参数顺序问题
- 日期：2025/2/6
- 类型：构建错误
- 描述：frame修饰符中参数顺序不正确导致编译错误
- 影响：项目无法编译，出现"Argument 'idealWidth' must precede argument 'minHeight'"错误
- 解决方案：
  1. 调整参数顺序，确保width相关参数在height相关参数之前
  2. 遵循SwiftUI的参数顺序规范：
     - 先设置width相关参数（minWidth, idealWidth, maxWidth）
     - 再设置height相关参数（minHeight, idealHeight, maxHeight）
  3. 创建View扩展来封装常用的frame设置
- 预防措施：
  1. 熟悉SwiftUI修饰符的参数顺序规范
  2. 使用代码补全功能来避免参数顺序错误
  3. 在编写复杂frame修饰符时分行书写，提高可读性
  4. 使用View扩展中预定义的frame设置方法
  5. 定期代码审查，确保frame设置的一致性
  6. 在团队中统一使用扩展方法

#### 5.13 ChatMessage类型不符合Equatable协议
- 日期：2025/2/6
- 类型：编译错误
- 描述：ChatMessage类型在数组onChange方法中需要遵循Equatable协议
- 影响：项目无法编译，影响消息列表的状态监听功能
- 解决方案：
  1. 为ChatMessage添加Equatable协议支持
  2. 实现==操作符，基于id进行相等性比较
  3. 确保其他相关模型也正确实现了必要的协议
- 预防措施：
  1. 在使用SwiftUI的onChange修饰符时，确保相关类型遵循必要的协议
  2. 为所有需要比较相等性的模型类型实现Equatable协议
  3. 在模型设计阶段就考虑协议遵循的需求
  4. 建立模型协议遵循的检查清单
  5. 定期审查模型类型的协议实现

#### 5.14 Double和CGFloat类型转换问题
- 日期：2025/2/6
- 类型：编译错误
- 描述：UserDefaults中存储的Double类型无法直接转换为CGFloat
- 影响：项目无法编译，出现"'Double' is not convertible to 'CGFloat'"错误
- 解决方案：
  1. 存储时将CGFloat转换为Double：`UserDefaults.standard.set(Double(fontSize), forKey: "fontSize")`
  2. 读取时将Double转换为CGFloat：`CGFloat(UserDefaults.standard.double(forKey: "fontSize"))`
  3. 添加默认值处理，避免无效值：`CGFloat(...) > 0 ? CGFloat(...) : defaultValue`
- 预防措施：
  1. 注意Swift中数值类型的转换规则
  2. 在处理UserDefaults存储时考虑类型兼容性
  3. 为所有数值类型设置合理的默认值
  4. 添加数值范围检查
  5. 使用类型安全的包装器处理数据存储

#### 5.15 目录选择状态管理问题
- 日期：2025/2/6
- 类型：功能缺陷
- 描述：点击子级目录后，子级目录栏被清空，显示"请选择父目录"；父级目录选择不能锁定；子级目录显示不能保持
- 影响：用户无法正常浏览和选择文档，影响用户体验
- 解决方案：
  1. 参考问题5.19的解决方案，修正ViewModel的初始化顺序和实例传递问题
  2. 确保DirectoryViewModel使用正确的DocumentViewModel实例
  3. 移除不必要的状态标志和复杂的状态管理逻辑
  4. 添加详细日志跟踪状态变化，方便调试
- 预防措施：
  1. 在使用@StateObject时，注意避免重复创建ViewModel实例
  2. 确保ViewModel之间的依赖关系正确传递
  3. 使用日志跟踪状态变化，及时发现异常
  4. 在开发时注意检查ViewModel的生命周期
  5. 遵循SwiftUI的状态管理最佳实践

#### 5.16 目录选择状态持久化问题
- 日期：2025/2/6
- 类型：功能缺陷
- 描述：子目录选择状态在父目录切换时无法正确保持，即使添加了状态标志位仍然会出现状态丢失
- 影响：用户在浏览文档时体验不连贯，需要重复选择目录
- 解决方案：
  1. 参考问题5.19的解决方案，确保ViewModel实例的正确性和唯一性
  2. 移除复杂的状态持久化逻辑，依赖正确的ViewModel实例管理
  3. 简化状态管理，避免使用异步操作和复杂的状态标志
- 预防措施：
  1. 确保ViewModel的正确初始化和依赖传递
  2. 避免创建重复的ViewModel实例
  3. 保持状态管理逻辑的简单性
  4. 添加必要的日志跟踪
  5. 在修改状态时考虑SwiftUI的更新机制

#### 5.17 目录选择死锁问题
- 日期：2025/2/6
- 类型：严重缺陷
- 描述：选择子目录时出现死锁，导致应用卡死，原因是父子目录状态更新之间存在循环依赖；选择子目录时，子目录显示会被清空
- 影响：用户无法正常使用目录选择功能，严重影响应用可用性
- 解决方案：
  1. 参考问题5.19的解决方案，修正ViewModel的初始化和实例传递问题
  2. 移除不必要的状态管理逻辑和循环依赖
  3. 保持父子目录状态管理的独立性
  4. 简化状态更新流程
- 预防措施：
  1. 确保ViewModel的正确初始化和依赖传递
  2. 避免创建重复的ViewModel实例
  3. 保持状态管理逻辑的简单性
  4. 避免使用复杂的状态标志系统
  5. 定期检查和测试目录选择功能的稳定性

#### 5.18 子目录选择状态问题
- 日期：2025/2/6
- 类型：功能缺陷
- 描述：选择子目录时，子目录状态发生变化，导致界面显示不符合预期
- 影响：用户在浏览文档时，子目录列表的显示状态不正确
- 解决方案：
  1. 参考问题5.19的解决方案，修正ViewModel的初始化问题
  2. 确保使用正确的DocumentViewModel实例
  3. 简化状态管理逻辑
  4. 移除不必要的状态检查
- 预防措施：
  1. 确保ViewModel的正确初始化和依赖传递
  2. 避免创建重复的ViewModel实例
  3. 保持状态管理的简单性
  4. 仔细测试状态变更的影响
  5. 记录状态变更的日志

#### 5.19 ViewModel初始化顺序导致的状态管理问题
- 日期：2025/2/6
- 类型：状态管理错误
- 描述：在`AIWritingAssistantApp.swift`中，由于ViewModel的初始化顺序和重复初始化问题，导致子目录在选择操作时被异常清空。具体表现为：选择父目录"快速笔记"后选择子目录"How to save time"，然后选择父目录"日本游"后选择子目录"行程规划"时，每次选择子目录都会导致子目录列表被清空。
- 影响：用户无法正常浏览和选择文档，严重影响用户体验
- 解决方案：
  1. 修改`AIWritingAssistantApp.swift`中的ViewModel初始化逻辑，避免重复创建DocumentViewModel实例
  2. 将原来的代码：
     ```swift
     init() {
         let docVM = DocumentViewModel()
         _documentViewModel = StateObject(wrappedValue: docVM)
         _directoryViewModel = StateObject(wrappedValue: DirectoryViewModel(documentViewModel: docVM))
         _chatViewModel = StateObject(wrappedValue: ChatViewModel())
     }
     ```
     修改为直接使用已声明的documentViewModel：
     ```swift
     init() {
         _documentViewModel = StateObject(wrappedValue: DocumentViewModel())
         _directoryViewModel = StateObject(wrappedValue: DirectoryViewModel(documentViewModel: documentViewModel))
         _chatViewModel = StateObject(wrappedValue: ChatViewModel())
     }
     ```
  3. 确保ViewModel之间的依赖关系正确传递
  4. 添加状态变化的日志跟踪，方便调试
- 预防措施：
  1. 在使用@StateObject时，注意避免重复创建ViewModel实例
  2. 明确ViewModel之间的依赖关系和初始化顺序
  3. 使用日志跟踪状态变化，及时发现异常
  4. 在开发时注意检查ViewModel的生命周期
  5. 遵循SwiftUI的状态管理最佳实践
  6. 在代码审查时特别关注ViewModel的初始化逻辑

#### 5.20 结构体属性修改问题
- 日期：2025/2/6
- 类型：编译错误
- 描述：在`DataStore.swift`中，使用`let`声明的`Directory`结构体实例无法修改其`children`属性
- 影响：项目无法编译，出现"Cannot assign to property: 'xxx' is a 'let' constant"错误
- 解决方案：
  1. 将`let`声明改为`var`，使结构体实例可变
  2. 在声明时就完整初始化结构体的所有属性
  3. 添加注释说明变量的用途
- 预防措施：
  1. 在使用结构体时，注意其值类型的特性
  2. 如果需要修改属性，使用`var`声明
  3. 在代码审查时特别注意结构体的可变性
  4. 添加适当的注释说明变量的用途和生命周期
  5. 考虑使用类而不是结构体，如果需要频繁修改属性

#### 5.21 UUID强制解包和数据文件初始化问题
- 日期：2025/2/6
- 类型：运行时错误
- 描述：在`DataStore.swift`中，UUID(uuidString:)的强制解包导致运行时崩溃；同时数据文件的初始化逻辑不完整
- 影响：应用启动时崩溃，出现"Thread 1: Fatal error: Unexpectedly found nil while unwrapping an Optional value"错误
- 解决方案：
  1. 使用可选绑定替代强制解包：`UUID(uuidString: "xxx") ?? UUID()`
  2. 完善数据文件初始化逻辑：
     ```swift
     private func createDataFilesIfNeeded() {
         print("检查数据文件...")
         if !fileExists(at: directoriesFile) {
             print("目录数据文件不存在，创建默认数据")
             saveDefaultDirectories()
         }
         if !fileExists(at: documentsFile) {
             print("文档数据文件不存在，创建默认数据")
             saveDefaultDocuments()
         }
     }
     ```
  3. 添加详细的日志输出，方便调试
  4. 使用`JSONEncoder`的`prettyPrinted`格式化输出
  5. 分离目录和文档的默认数据创建逻辑
- 预防措施：
  1. 避免使用强制解包，特别是在处理可能失败的初始化时
  2. 完善数据初始化逻辑，确保所有必要的文件都被正确创建
  3. 添加详细的日志输出，方便问题定位
  4. 使用格式化的JSON输出，方便调试和查看
  5. 分离不同类型数据的处理逻辑，提高代码可维护性

#### 5.22 文档保存和数据持久化问题
- 日期：2025/2/6
- 类型：功能缺陷
- 描述：文档内容修改后无法正确保存，当前使用JSON文件存储方式可能导致性能和并发问题
- 影响：用户修改的文档内容无法保存，影响用户体验和数据完整性
- 解决方案：
  1. 在DirectoryViewModel中添加文档内容变更监听
  2. 在DocumentViewModel中实现内容更新回调
  3. 完善DataStore的文档保存逻辑
  4. 建议后续改用Core Data实现数据持久化：
     ```swift
     // Core Data 实体设计
     // Directory 实体
     - id: UUID
     - name: String
     - path: String
     - isParent: Bool
     - children: Set<Directory>
     - documents: Set<Document>
     - createdAt: Date
     - updatedAt: Date
     
     // Document 实体
     - id: UUID
     - title: String
     - content: String
     - path: String
     - directory: Directory
     - createdAt: Date
     - updatedAt: Date
     ```
- 预防措施：
  1. 实现数据变更的实时监听和保存
  2. 使用数据库替代文件存储，提高性能和可靠性
  3. 添加数据完整性检查和错误恢复机制
  4. 实现定期数据备份功能
  5. 添加详细的操作日志，方便问题追踪

#### 5.23 富文本编辑器格式保存问题
- 日期：2025/2/6
- 类型：功能缺陷
- 描述：富文本格式在保存后可能丢失，或者在重新打开文档时格式显示不正确
- 影响：用户编辑的文本格式无法正确保存和恢复
- 解决方案：
  1. 使用NSAttributedString的data方法保存富文本内容
  2. 使用RTF格式存储富文本数据
  3. 在Document模型中添加attributedContent字段
  4. 实现正确的数据转换和错误处理
  5. 添加格式恢复的日志跟踪
- 预防措施：
  1. 在保存文档时同时保存纯文本和富文本内容
  2. 添加格式转换的错误处理
  3. 实现格式恢复的回退机制
  4. 定期测试格式保存和恢复功能
  5. 记录详细的操作日志

#### 5.24 文本选择状态管理问题
- 日期：2025/2/6
- 类型：功能缺陷
- 描述：在应用格式（如加粗、改变颜色）时，文本选择状态可能不正确或丢失
- 影响：用户无法正确应用文本格式，影响编辑体验
- 解决方案：
  1. 使用NSTextView的selectedRange属性跟踪选择状态
  2. 在文本变更时正确更新选择范围
  3. 确保格式应用前检查选择范围的有效性
  4. 优化选择状态的更新逻辑
- 预防措施：
  1. 在应用格式前验证选择范围
  2. 添加选择状态的日志跟踪
  3. 实现选择状态的恢复机制
  4. 定期测试选择相关功能
  5. 注意处理边界情况

#### 5.25 富文本编辑性能优化
- 日期：2025/2/6
- 类型：性能优化
- 描述：在处理大量富文本内容时，编辑器可能出现性能问题
- 影响：编辑大文档时可能出现卡顿或响应延迟
- 解决方案：
  1. 使用NSTextStorage的异步更新机制
  2. 优化属性字符串的处理逻辑
  3. 实现增量更新机制
  4. 添加文本处理的缓存机制
  5. 优化格式应用的性能
- 预防措施：
  1. 监控文本处理的性能指标
  2. 实现大文档的分段加载
  3. 优化格式应用的算法
  4. 添加性能日志跟踪
  5. 定期进行性能测试

#### 5.26 富文本编辑器数据模型问题
- 日期：2025/2/6
- 类型：编译错误
- 描述：Document 模型中缺少 attributedContent 属性，导致富文本编辑器无法正常工作
- 影响：编译错误，富文本编辑功能无法使用
- 解决方案：
  1. 在 Document 结构体中添加 attributedContent: Data? 属性
  2. 更新 Document 的初始化方法
  3. 在 Core Data 的 DocumentEntity 中添加 attributedContent 属性（Binary 类型）
  4. 更新 Document 的 Core Data 转换支持
  5. 确保所有使用 Document 的地方都正确处理 attributedContent
- 预防措施：
  1. 在添加新功能时，确保同时更新所有相关的数据模型
  2. 在实现新功能前，先完成数据模型的设计和更新
  3. 使用版本控制管理数据模型的变更
  4. 添加数据模型的单元测试
  5. 记录数据模型的变更历史

#### 5.27 富文本编辑器与文档模型集成问题
- 日期：2024/4/23
- 类型：功能缺陷
- 描述：富文本编辑器的样式变更（字体大小、颜色等）无法正确保存到文档模型，导致在重新打开文档时样式丢失
- 影响：用户富文本编辑内容无法持久化，影响编辑体验和功能完整性
- 解决方案：
  1. 确保Document模型中的attributedContent字段正确存储富文本数据
  2. 优化EditorView中的富文本数据转换逻辑
  3. 在DocumentViewModel中添加富文本保存的专用方法
  4. 实现富文本内容变更的实时监听和保存
  5. 添加数据格式转换的错误处理
- 预防措施：
  1. 添加富文本格式转换的单元测试
  2. 实现文档数据自动备份机制
  3. 完善富文本处理的日志记录
  4. 考虑使用更可靠的数据格式（如RTF或HTML）
  5. 在保存和读取过程中添加数据验证

#### 5.28 系统图标名称错误问题
- 日期：2024/4/23
- 类型：UI错误
- 描述：ContentView中使用了不存在的系统图标名称"sidebar.leading.fill"和"sidebar.trailing.fill"，导致控制台报错并且图标显示不正确
- 影响：当侧边栏被隐藏时，工具栏上的图标显示不正确，影响用户体验
- 解决方案：
  1. 将不存在的图标名称替换为正确的系统图标名称
  2. 使用"sidebar.left"替换"sidebar.leading"和"sidebar.leading.fill"
  3. 使用"sidebar.right"替换"sidebar.trailing"和"sidebar.trailing.fill"
  4. 保持图标一致性，不再根据侧边栏显示状态切换不同图标
- 预防措施：
  1. 使用图标前先在SF Symbols应用中查询确认图标名称是否存在
  2. 尽量使用系统提供的标准图标，避免使用自定义或不常见的图标名称
  3. 在开发过程中及时关注控制台错误信息
  4. 如果需要切换图标，确保两种状态的图标都存在
  5. 考虑使用图标预览功能验证图标的正确性

### 6. AI集成问题

#### 6.1 Core Data集成和数据迁移问题
- 日期：2025/2/6
- 类型：功能缺陷
- 描述：Core Data已集成但未完全启用，导致目录和文档显示为空
- 影响：用户无法看到任何目录和文档内容
- 解决方案：
  1. 完善DataStore的数据文件检查和创建逻辑
  2. 在DirectoryViewModel中添加CoreDataManager支持
  3. 实现数据从JSON文件到Core Data的迁移功能
  4. 添加迁移状态检查，避免重复迁移
  5. 增加详细的日志输出，方便调试
- 预防措施：
  1. 在进行数据存储方式切换时，确保数据迁移的完整性
  2. 添加充分的日志输出，方便问题定位
  3. 实现数据一致性检查
  4. 提供数据恢复机制
  5. 定期备份重要数据

## 问题记录模板

### [问题描述]
- 日期：
- 类型：
- 描述：
- 影响：
- 解决方案：
- 预防措施：

## 已解决问题列表
1. FileManager 命名冲突（2025/2/6）
2. SwiftUI API 废弃警告（2025/2/6）
3. 未使用变量警告（2025/2/6）
4. 界面布局优化（2025/2/6）
5. 类型不符合 Hashable 协议错误（2025/2/6）
6. 侧边栏宽度调整（2025/2/6）
7. 文档编辑功能增强（2025/2/6）
8. 目录选择功能问题（2025/2/6）
9. 文档切换功能问题（2025/2/6）
10. 响应式布局问题（2025/2/6）
11. 动画性能优化（2025/2/6）
12. 滚动性能优化（2025/2/6）
13. 主题切换优化（2025/2/6）
14. SwiftUI frame参数顺序问题（2025/2/6）
15. ChatMessage类型不符合Equatable协议（2025/2/6）
16. Double和CGFloat类型转换问题（2025/2/6）
17. 目录选择状态管理问题（2025/2/6）
18. 目录选择状态持久化问题（2025/2/6）
19. 目录选择死锁问题（2025/2/6）
20. 子目录选择状态问题（2025/2/6）
21. ViewModel初始化顺序导致的状态管理问题（2025/2/6）
22. 结构体属性修改问题（2025/2/6）
23. UUID强制解包和数据文件初始化问题（2025/2/6）
24. 文档保存和数据持久化问题（2025/2/6）
25. Core Data集成和数据迁移（2025/2/6）
26. 富文本编辑器格式保存问题（2025/2/6）
27. 文本选择状态管理问题（2025/2/6）
28. 富文本编辑性能优化（2025/2/6）
29. 富文本编辑器数据模型问题（2025/2/6）
30. 富文本编辑器与文档模型集成问题（2024/4/23）
31. 系统图标名称错误问题（2024/4/23）

## 待解决问题列表
1. 深色模式适配
2. 动画性能优化
3. 滚动性能优化
4. 主题切换优化
5. AI服务集成
6. 文件存储实现
7. 富文本编辑器与文档模型集成

## 常见问题解答（FAQ）
1. 为什么要避免使用与系统框架相同的命名？
   - 避免命名冲突
   - 提高代码可读性
   - 减少潜在的编译错误

2. 如何处理 API 废弃警告？
   - 及时更新到新版本 API
   - 关注官方文档的更新
   - 在更新时注意兼容性问题

3. 如何保持界面设计的一致性？
   - 使用统一的常量系统
   - 遵循设计规范
   - 定期进行UI审查
